<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de F√≠sica - Cinem√°tica Interativa</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // √çcones SVG inline
        const PlayIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const PauseIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const RotateCcwIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        );

        const TargetIcon = () => (
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const CodeIcon = () => (
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
            </svg>
        );

        const TrendingUpIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
            </svg>
        );

        const PhysicsSimulator = () => {
          const canvasRef = useRef(null);
          const [isRunning, setIsRunning] = useState(false);
          const [code, setCode] = useState(`// Desafio: Fa√ßa o objeto subir 15 metros
// Posi√ß√£o inicial: (0, 0)
// Objetivo: y >= 15

function calcularFisica(t, dt) {
  // t = tempo atual (s)
  // dt = delta time (s)
  
  // Defina a velocidade inicial (m/s)
  const v0 = { x: 0, y: 20 };
  
  // Defina a acelera√ß√£o (m/s¬≤)
  const a = { x: 0, y: -9.8 }; // gravidade
  
  // Cinem√°tica:
  // v = v0 + a*t
  // s = s0 + v0*t + (1/2)*a*t¬≤
  
  const velocidade = {
    x: v0.x + a.x * t,
    y: v0.y + a.y * t
  };
  
  const posicao = {
    x: v0.x * t + 0.5 * a.x * t * t,
    y: v0.y * t + 0.5 * a.y * t * t
  };
  
  return { posicao, velocidade, aceleracao: a };
}`);
          
          const [challenge, setChallenge] = useState({
            title: "Desafio 1: Subida Vertical",
            description: "Fa√ßa o objeto subir at√© pelo menos 15 metros de altura",
            objective: { type: 'height', value: 15 },
            initialPos: { x: 0, y: 0 }
          });
          
          const [simulation, setSimulation] = useState({
            time: 0,
            position: { x: 0, y: 0 },
            velocity: { x: 0, y: 0 },
            acceleration: { x: 0, y: 0 },
            trajectory: [],
            maxHeight: 0,
            success: false
          });
          
          const [error, setError] = useState(null);
          const [showGraphs, setShowGraphs] = useState(true);

          const challenges = [
            {
              title: "Desafio 1: Subida Vertical",
              description: "Fa√ßa o objeto subir at√© pelo menos 15 metros",
              objective: { type: 'height', value: 15 },
              initialPos: { x: 0, y: 0 }
            },
            {
              title: "Desafio 2: Movimento Horizontal",
              description: "Mova o objeto 20 metros para a direita em 4 segundos",
              objective: { type: 'position', x: 20, y: 0, time: 4, tolerance: 2 },
              initialPos: { x: 0, y: 0 }
            },
            {
              title: "Desafio 3: Lan√ßamento Parab√≥lico",
              description: "Acerte o alvo em (30, 10) metros",
              objective: { type: 'target', x: 30, y: 10, tolerance: 2 },
              initialPos: { x: 0, y: 0 }
            },
            {
              title: "Desafio 4: Pouso Suave",
              description: "Suba 25m e volte ao solo com velocidade < 5 m/s",
              objective: { type: 'softLanding', height: 25, maxVelocity: 5 },
              initialPos: { x: 0, y: 0 }
            }
          ];

          const resetSimulation = () => {
            setIsRunning(false);
            setSimulation({
              time: 0,
              position: { ...challenge.initialPos },
              velocity: { x: 0, y: 0 },
              acceleration: { x: 0, y: 0 },
              trajectory: [],
              maxHeight: 0,
              success: false
            });
            setError(null);
          };

          const checkObjective = (sim) => {
            const obj = challenge.objective;
            
            switch(obj.type) {
              case 'height':
                return sim.maxHeight >= obj.value;
              
              case 'position':
                if (Math.abs(sim.time - obj.time) < 0.1) {
                  const dx = Math.abs(sim.position.x - obj.x);
                  const dy = Math.abs(sim.position.y - obj.y);
                  return dx < obj.tolerance && dy < obj.tolerance;
                }
                return false;
              
              case 'target':
                const dist = Math.sqrt(
                  Math.pow(sim.position.x - obj.x, 2) + 
                  Math.pow(sim.position.y - obj.y, 2)
                );
                return dist < obj.tolerance && sim.position.y <= 0.1;
              
              case 'softLanding':
                if (sim.maxHeight >= obj.height && sim.position.y <= 0.1) {
                  const speed = Math.sqrt(sim.velocity.x ** 2 + sim.velocity.y ** 2);
                  return speed <= obj.maxVelocity;
                }
                return false;
              
              default:
                return false;
            }
          };

          useEffect(() => {
            if (!isRunning) return;

            const dt = 0.016; // ~60 FPS
            let lastTime = Date.now();

            const interval = setInterval(() => {
              const now = Date.now();
              const elapsed = (now - lastTime) / 1000;
              
              setSimulation(prev => {
                const newTime = prev.time + dt;
                
                try {
                  // Executa o c√≥digo do usu√°rio
                  const userFunction = new Function('t', 'dt', code + '\\nreturn calcularFisica(t, dt);');
                  const result = userFunction(newTime, dt);
                  
                  if (!result || !result.posicao || !result.velocidade) {
                    throw new Error("Fun√ß√£o deve retornar { posicao, velocidade, aceleracao }");
                  }
                  
                  const newPos = result.posicao;
                  const newVel = result.velocidade;
                  const newAcc = result.aceleracao || { x: 0, y: 0 };
                  
                  const newTrajectory = [...prev.trajectory, { x: newPos.x, y: newPos.y, t: newTime }];
                  if (newTrajectory.length > 500) newTrajectory.shift();
                  
                  const newMaxHeight = Math.max(prev.maxHeight, newPos.y);
                  
                  const newSim = {
                    time: newTime,
                    position: newPos,
                    velocity: newVel,
                    acceleration: newAcc,
                    trajectory: newTrajectory,
                    maxHeight: newMaxHeight,
                    success: prev.success
                  };
                  
                  // Verifica objetivo
                  if (!prev.success && checkObjective(newSim)) {
                    newSim.success = true;
                    setIsRunning(false);
                  }
                  
                  // Para se passar de 10 segundos ou sair muito dos limites
                  if (newTime > 10 || Math.abs(newPos.x) > 100 || newPos.y < -10) {
                    setIsRunning(false);
                  }
                  
                  setError(null);
                  return newSim;
                  
                } catch (err) {
                  setError(err.message);
                  setIsRunning(false);
                  return prev;
                }
              });
              
              lastTime = now;
            }, 16);

            return () => clearInterval(interval);
          }, [isRunning, code, challenge]);

          // Renderiza√ß√£o do Canvas
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Limpa canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            // Sistema de coordenadas: 1 metro = 8 pixels
            const scale = 8;
            const originX = 50;
            const originY = height - 50;
            
            // Desenha grid
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= width; x += scale * 5) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, height);
              ctx.stroke();
            }
            
            for (let y = 0; y <= height; y += scale * 5) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(width, y);
              ctx.stroke();
            }
            
            // Eixos
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(width, originY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, height);
            ctx.stroke();
            
            // Desenha objetivo
            const obj = challenge.objective;
            ctx.fillStyle = '#22d3ee44';
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            
            if (obj.type === 'height') {
              const targetY = originY - obj.value * scale;
              ctx.fillRect(0, targetY - 2, width, 4);
              ctx.font = '14px monospace';
              ctx.fillStyle = '#22d3ee';
              ctx.fillText(`Meta: ${obj.value}m`, 10, targetY - 10);
            } else if (obj.type === 'target') {
              const tx = originX + obj.x * scale;
              const ty = originY - obj.y * scale;
              ctx.beginPath();
              ctx.arc(tx, ty, obj.tolerance * scale, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            }
            
            // Desenha trajet√≥ria
            if (simulation.trajectory.length > 1) {
              ctx.strokeStyle = '#60a5fa';
              ctx.lineWidth = 2;
              ctx.beginPath();
              
              simulation.trajectory.forEach((point, i) => {
                const x = originX + point.x * scale;
                const y = originY - point.y * scale;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              });
              
              ctx.stroke();
            }
            
            // Desenha objeto
            const objX = originX + simulation.position.x * scale;
            const objY = originY - simulation.position.y * scale;
            
            ctx.fillStyle = simulation.success ? '#10b981' : '#f59e0b';
            ctx.beginPath();
            ctx.arc(objX, objY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Desenha vetores de velocidade e acelera√ß√£o
            const velScale = 3;
            const accScale = 10;
            
            // Vetor velocidade (azul)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(objX, objY);
            ctx.lineTo(
              objX + simulation.velocity.x * velScale,
              objY - simulation.velocity.y * velScale
            );
            ctx.stroke();
            
            // Vetor acelera√ß√£o (vermelho)
            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            ctx.moveTo(objX, objY);
            ctx.lineTo(
              objX + simulation.acceleration.x * accScale,
              objY - simulation.acceleration.y * accScale
            );
            ctx.stroke();
            
          }, [simulation, challenge]);

          return (
            <div className="w-full h-screen bg-slate-950 text-white p-4 flex gap-4">
              {/* Painel Esquerdo - Editor */}
              <div className="w-1/2 flex flex-col gap-4">
                <div className="bg-slate-900 rounded-lg p-4 border border-slate-800">
                  <div className="flex items-center gap-2 mb-3">
                    <TargetIcon />
                    <h2 className="text-xl font-bold">{challenge.title}</h2>
                  </div>
                  <p className="text-slate-300 mb-3">{challenge.description}</p>
                  
                  <div className="flex gap-2 flex-wrap">
                    {challenges.map((ch, i) => (
                      <button
                        key={i}
                        onClick={() => {
                          setChallenge(ch);
                          resetSimulation();
                        }}
                        className={`px-3 py-1 rounded text-sm transition ${
                          ch.title === challenge.title
                            ? 'bg-cyan-600 text-white'
                            : 'bg-slate-800 text-slate-300 hover:bg-slate-700'
                        }`}
                      >
                        Desafio {i + 1}
                      </button>
                    ))}
                  </div>
                </div>

                <div className="flex-1 bg-slate-900 rounded-lg border border-slate-800 flex flex-col">
                  <div className="flex items-center gap-2 p-3 border-b border-slate-800">
                    <CodeIcon />
                    <h3 className="font-semibold">Editor de F√≠sica</h3>
                  </div>
                  
                  <textarea
                    value={code}
                    onChange={(e) => setCode(e.target.value)}
                    className="flex-1 bg-slate-950 p-4 font-mono text-sm resize-none focus:outline-none"
                    spellCheck={false}
                  />
                  
                  {error && (
                    <div className="p-3 bg-red-950 border-t border-red-800 text-red-300 text-sm">
                      ‚ö†Ô∏è {error}
                    </div>
                  )}
                </div>

                <div className="bg-slate-900 rounded-lg p-4 border border-slate-800">
                  <div className="flex gap-2">
                    <button
                      onClick={() => setIsRunning(!isRunning)}
                      className="flex-1 bg-green-600 hover:bg-green-700 px-4 py-2 rounded font-semibold flex items-center justify-center gap-2 transition"
                    >
                      {isRunning ? <PauseIcon /> : <PlayIcon />}
                      {isRunning ? 'Pausar' : 'Simular'}
                    </button>
                    
                    <button
                      onClick={resetSimulation}
                      className="bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded font-semibold flex items-center gap-2 transition"
                    >
                      <RotateCcwIcon />
                      Reset
                    </button>
                    
                    <button
                      onClick={() => setShowGraphs(!showGraphs)}
                      className="bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded font-semibold flex items-center gap-2 transition"
                    >
                      <TrendingUpIcon />
                      Gr√°ficos
                    </button>
                  </div>
                </div>
              </div>

              {/* Painel Direito - Visualiza√ß√£o */}
              <div className="w-1/2 flex flex-col gap-4">
                <div className="bg-slate-900 rounded-lg p-4 border border-slate-800">
                  <canvas
                    ref={canvasRef}
                    width={600}
                    height={400}
                    className="w-full bg-slate-950 rounded"
                  />
                  
                  {simulation.success && (
                    <div className="mt-3 p-3 bg-green-950 border border-green-800 rounded text-green-300 text-center font-semibold">
                      üéâ OBJETIVO ALCAN√áADO! üéâ
                    </div>
                  )}
                </div>

                <div className="bg-slate-900 rounded-lg p-4 border border-slate-800">
                  <h3 className="font-semibold mb-3">Telemetria em Tempo Real</h3>
                  
                  <div className="grid grid-cols-2 gap-3 text-sm font-mono">
                    <div className="bg-slate-950 p-2 rounded">
                      <div className="text-slate-400">Tempo</div>
                      <div className="text-lg text-cyan-400">{simulation.time.toFixed(2)}s</div>
                    </div>
                    
                    <div className="bg-slate-950 p-2 rounded">
                      <div className="text-slate-400">Altura M√°xima</div>
                      <div className="text-lg text-amber-400">{simulation.maxHeight.toFixed(2)}m</div>
                    </div>
                    
                    <div className="bg-slate-950 p-2 rounded">
                      <div className="text-slate-400">Posi√ß√£o</div>
                      <div className="text-blue-400">
                        x: {simulation.position.x.toFixed(2)}m
                      </div>
                      <div className="text-blue-400">
                        y: {simulation.position.y.toFixed(2)}m
                      </div>
                    </div>
                    
                    <div className="bg-slate-950 p-2 rounded">
                      <div className="text-slate-400">Velocidade</div>
                      <div className="text-blue-400">
                        vx: {simulation.velocity.x.toFixed(2)}m/s
                      </div>
                      <div className="text-blue-400">
                        vy: {simulation.velocity.y.toFixed(2)}m/s
                      </div>
                    </div>
                    
                    <div className="bg-slate-950 p-2 rounded col-span-2">
                      <div className="text-slate-400">Acelera√ß√£o</div>
                      <div className="text-red-400">
                        ax: {simulation.acceleration.x.toFixed(2)}m/s¬≤ | 
                        ay: {simulation.acceleration.y.toFixed(2)}m/s¬≤
                      </div>
                    </div>
                  </div>
                </div>

                {showGraphs && (
                  <div className="bg-slate-900 rounded-lg p-4 border border-slate-800">
                    <h3 className="font-semibold mb-3">Gr√°ficos</h3>
                    <div className="space-y-2 text-sm">
                      <div>
                        <div className="text-slate-400 mb-1">Posi√ß√£o Y (m)</div>
                        <div className="h-12 bg-slate-950 rounded relative overflow-hidden">
                          {simulation.trajectory.map((point, i) => {
                            const x = (i / simulation.trajectory.length) * 100;
                            const y = 100 - ((point.y + 10) / 50) * 100;
                            return (
                              <div
                                key={i}
                                className="absolute w-1 bg-blue-400"
                                style={{
                                  left: `${x}%`,
                                  bottom: '0',
                                  height: `${Math.max(0, Math.min(100, y))}%`
                                }}
                              />
                            );
                          })}
                        </div>
                      </div>
                      
                      <div className="text-xs text-slate-500 mt-2">
                        üîµ Velocidade (azul) | üî¥ Acelera√ß√£o (vermelho)
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PhysicsSimulator />);
    </script>
</body>
</html>
